use general::{get_args, read_data_lines, reset_sigpipe};
use regex::Regex;
use std::collections::{BTreeMap, HashSet, VecDeque};
use std::error::Error;
use std::io::{self, Write};

fn get_data(data: &[String]) -> BTreeMap<String, (u64, Vec<String>)> {
    // ex.                Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
    // ex.                Valve HH has flow rate=22; tunnel leads to valve GG
    let valve_re =
        Regex::new(r"Valve (\S+) has flow rate=(\d+); tunnel[s]? lead[s]? to valve[s]? (.*)")
            .unwrap();
    let mut valves = BTreeMap::new();
    for line in data {
        if valve_re.is_match(line) {
            let captures = valve_re.captures(line).unwrap();
            let valve = captures.get(1).map(|s| s.as_str().to_string()).unwrap();
            let rate = captures
                .get(2)
                .map(|s| s.as_str().parse::<u64>().unwrap())
                .unwrap();
            let leads_to = captures
                .get(3)
                .map(|s| s.as_str().to_string())
                .unwrap()
                .split(',')
                .map(|s| s.trim().to_string())
                .collect::<Vec<_>>();
            valves.insert(valve, (rate, leads_to));
        }
    }
    valves
}

fn dfs(
    time: i64,
    valve: String,
    bitmask: i64,
    dists: &BTreeMap<String, BTreeMap<String, usize>>,
    valves: &BTreeMap<String, i64>,
    cache: &mut BTreeMap<(i64, String, i64), i64>,
    indices: &BTreeMap<String, usize>,
) -> i64 {
    if cache.contains_key(&(time, valve.clone(), bitmask)) {
        return cache[&(time, valve, bitmask)];
    }

    let mut maxval = 0;
    for neighbor in dists[&valve].keys() {
        let bit = 1 << indices[neighbor];
        if bitmask & bit != 0 {
            continue;
        }
        let remtime = time - dists[&valve][neighbor] as i64 - 1;
        if remtime <= 0 {
            continue;
        }
        maxval = maxval.max(
            dfs(
                remtime,
                neighbor.to_string(),
                bitmask | bit,
                dists,
                valves,
                cache,
                indices,
            ) + valves[neighbor] * remtime,
        );
    }
    cache.insert((time, valve, bitmask), maxval);
    maxval
}

fn solve11(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    let mut tunnels = BTreeMap::new();
    let mut valves = BTreeMap::new();
    let mut names = vec![];
    let mut flows = vec![];
    for (k, v) in &get_data(puzzle_lines) {
        valves.insert(k.to_string(), v.0 as i64);
        flows.push(v.0);
        tunnels.insert(k.to_string(), v.1.clone());
        names.push(k.to_string());
    }

    let mut dist = vec![];
    for _ in 0..names.len() {
        dist.push(vec![99; names.len()]);
    }

    for (i, valve) in valves.keys().enumerate() {
        for neighbor in &tunnels[valve] {
            let index = names.iter().position(|r| r == neighbor).unwrap();
            let v = &mut dist[i];
            v[index] = 1;
        }
    }


    // Floyd-Marshall
    for k in 0..names.len() {
        for i in 0..names.len() {
            for j in 0..names.len() {
                dist[i][j] = dist[i][j].min(dist[i][k] + dist[k][j]);
            }
        }
    }

    let rest = flows.iter().enumerate().filter(|(_,f)| *f > &0).map(|(i,_)| i as u64).collect::<Vec<u64>>();
    //println!("names = {:?}", names);
    //let aa_index = names.iter().position(|r| r == "AA").unwrap();
    //println!("aa in names = {:?}", names.iter().position(|r| r == "AA").unwrap());
    //println!("rest = {:?}", rest);
    let mut cache = BTreeMap::<(usize, Vec<u64>, u64), u64>::new();
    Ok(dfs2(&dist, &flows, 0, &rest, 30, &mut cache))
}

fn choose_one(v: &[u64]) -> impl Iterator<Item = (u64, Vec<u64>)> {
        v.iter()
        .enumerate()
        .map(|(i, val)| {
            (
                *val,
                [&v[..i], &v[(i + 1)..]]
                    .iter()
                    .copied()
                    .flatten()
                    .copied()
                    .collect::<Vec<_>>(),
            )
        })
        .collect::<Vec<(_, _)>>()
        .into_iter()
}

fn dfs2(dist: &Vec<Vec<u64>>, flows: &[u64], cur: usize, rest: &[u64], t: u64, cache: &mut BTreeMap::<(usize, Vec<u64>, u64), u64>) -> u64 {
    if let Some(val) = cache.get(&(cur, rest.to_vec(), t)) {
        return *val;
    }
    /*
    let choose_one = |xs: &'static [u64]| {
        xs.iter()
            .enumerate()
            .map(|(i, val)| {
                (
                    val,
                    [&xs[..i], &xs[(i + 1)..]]
                        .iter()
                        .copied()
                        .flatten()
                        .copied()
                        .collect::<Vec<_>>(),
                )
            })
            .collect::<Vec<(_, _)>>()
            .into_iter()
    };
    */

    let mut maxval = 0;
    for (r, rr) in choose_one(&rest) {
        let r = r as usize;
        if dist[cur][r] < t {
            maxval = maxval.max(flows[r] * (t - dist[cur][r] - 1) + dfs2(dist, flows, r, &rr, t - dist[cur][r] - 1, cache));
        }
    }
    cache.insert((cur, rest.to_vec(), t), maxval);
    maxval
}

fn solve1(puzzle_lines: &[String]) -> Result<i64, Box<dyn Error>> {
    let mut tunnels = BTreeMap::new();
    let mut valves = BTreeMap::new();
    let mut dists = BTreeMap::new();
    for (k, v) in &get_data(puzzle_lines) {
        valves.insert(k.to_string(), v.0 as i64);
        tunnels.insert(k.to_string(), v.1.clone());
    }

    let mut nonempty = vec![];
    for valve in valves.keys() {
        if valve != "AA" && valves[valve] == 0 {
            continue;
        }

        if valve != "AA" {
            nonempty.push(valve);
        }

        let mut v1 = BTreeMap::new();
        v1.insert(valve.to_string(), 0);
        v1.insert("AA".to_string(), 0);
        dists.insert(valve.to_string(), v1);

        let mut visited = HashSet::<String>::new();
        visited.insert(valve.to_string());

        let mut queue = VecDeque::new();
        queue.push_back((0, valve.to_string()));

        while let Some((distance, position)) = queue.pop_front() {
            for neighbor in &tunnels[&position] {
                if visited.contains(neighbor) {
                    continue;
                }
                visited.insert(neighbor.to_string());

                if valves[neighbor] != 0 {
                    let v = dists.get_mut(valve).unwrap();
                    v.insert(neighbor.to_string(), distance + 1);
                }
                queue.push_back((distance + 1, neighbor.to_string()));
            }
        }

        let v = dists.get_mut(valve).unwrap();
        v.remove(valve);
        if valve != "AA" {
            let v1 = dists.get_mut(valve).unwrap();
            v1.remove("AA");
        }
    }

    let mut indices = BTreeMap::new();
    for (i, elem) in nonempty.iter().enumerate() {
        indices.insert(elem.to_string(), i);
    }

    let mut cache: BTreeMap<(i64, String, i64), i64> = BTreeMap::new();

    Ok(dfs(
        30,
        "AA".to_string(),
        0,
        &dists,
        &valves,
        &mut cache,
        &indices,
    ))
}

fn solve2(puzzle_lines: &[String]) -> Result<i64, Box<dyn Error>> {
    let mut tunnels = BTreeMap::new();
    let mut valves = BTreeMap::new();
    let mut dists = BTreeMap::new();
    for (k, v) in &get_data(puzzle_lines) {
        valves.insert(k.to_string(), v.0 as i64);
        tunnels.insert(k.to_string(), v.1.clone());
    }

    let mut nonempty = vec![];
    for valve in valves.keys() {
        if valve != "AA" && valves[valve] == 0 {
            continue;
        }

        if valve != "AA" {
            nonempty.push(valve);
        }

        let mut v1 = BTreeMap::new();
        v1.insert(valve.to_string(), 0);
        v1.insert("AA".to_string(), 0);
        dists.insert(valve.to_string(), v1);

        let mut visited = HashSet::<String>::new();
        visited.insert(valve.to_string());

        let mut queue = VecDeque::new();
        queue.push_back((0, valve.to_string()));

        while !queue.is_empty() {
            let (distance, position) = queue.pop_front().unwrap();
            for neighbor in &tunnels[&position] {
                if visited.contains(neighbor) {
                    continue;
                }
                visited.insert(neighbor.to_string());

                if valves[neighbor] != 0 {
                    let v = dists.get_mut(valve).unwrap();
                    v.insert(neighbor.to_string(), distance + 1);
                }
                queue.push_back((distance + 1, neighbor.to_string()));
            }
        }

        let v = dists.get_mut(valve).unwrap();
        v.remove(valve);
        if valve != "AA" {
            let v1 = dists.get_mut(valve).unwrap();
            v1.remove("AA");
        }
    }

    let mut indices = BTreeMap::new();
    for (i, elem) in nonempty.iter().enumerate() {
        indices.insert(elem.to_string(), i);
    }

    let mut cache: BTreeMap<(i64, String, i64), i64> = BTreeMap::new();

    let b = (1 << nonempty.len()) - 1;
    let mut m = 0;

    for i in 0..(b + 1) / 2 {
        m = m.max(
            dfs(
                26,
                "AA".to_string(),
                i,
                &dists,
                &valves,
                &mut cache,
                &indices,
            ) + dfs(
                26,
                "AA".to_string(),
                b ^ i,
                &dists,
                &valves,
                &mut cache,
                &indices,
            ),
        )
    }
    Ok(m)
}

fn part1(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    solve11(puzzle_lines)
    //solve1(puzzle_lines)
}

fn part2(puzzle_lines: &[String]) -> Result<i64, Box<dyn Error>> {
    solve2(puzzle_lines)
}

fn main() -> Result<(), Box<dyn Error>> {
    // behave like a typical unix utility
    reset_sigpipe()?;
    let mut stdout = io::stdout().lock();

    // parse command line arguments
    let args = get_args();

    // read puzzle data into a list of String
    let puzzle_lines = read_data_lines(args.get_one::<std::path::PathBuf>("FILE"))?;

    // start a timer
    let timer = std::time::Instant::now();

    // ==============================================================

    writeln!(stdout, "Answer Part 1 = {}", part1(&puzzle_lines)?)?;
    writeln!(stdout, "Answer Part 2 = {}", part2(&puzzle_lines)?)?;

    if args.get_flag("time") {
        writeln!(stdout, "Total Runtime: {:?}", timer.elapsed())?;
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_data(filename: &str) -> Vec<String> {
        let file = std::path::PathBuf::from(filename);
        read_data_lines(Some(&file)).unwrap()
    }

    #[test]
    fn part1_example() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-example");
        assert_eq!(part1(&puzzle_lines)?, 1651);
        Ok(())
    }

    #[test]
    fn part1_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part1(&puzzle_lines)?, 1376);
        Ok(())
    }

    #[test]
    fn part2_example() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-example");
        assert_eq!(part2(&puzzle_lines)?, 1707);
        Ok(())
    }

    #[test]
    fn part2_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part2(&puzzle_lines)?, 1933);
        Ok(())
    }
}
