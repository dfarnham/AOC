use general::{get_args, read_data_lines, reset_sigpipe};
use regex::Regex;
use std::collections::BTreeMap;
use std::error::Error;
use std::io::{self, Write};

fn get_data(data: &[String]) -> BTreeMap<String, (u64, Vec<String>)> {
    // ex.                Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
    // ex.                Valve HH has flow rate=22; tunnel leads to valve GG
    let valve_re =
        Regex::new(r"Valve (\S+) has flow rate=(\d+); tunnel[s]? lead[s]? to valve[s]? (.*)")
            .unwrap();
    let mut valves = BTreeMap::new();
    for line in data {
        if valve_re.is_match(line) {
            let captures = valve_re.captures(line).unwrap();
            let valve = captures.get(1).map(|s| s.as_str().to_string()).unwrap();
            let rate = captures
                .get(2)
                .map(|s| s.as_str().parse::<u64>().unwrap())
                .unwrap();
            let leads_to = captures
                .get(3)
                .map(|s| s.as_str().to_string())
                .unwrap()
                .split(',')
                .map(|s| s.trim().to_string())
                .collect::<Vec<_>>();
            valves.insert(valve, (rate, leads_to));
        }
    }
    valves
}

fn solve2(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    let mut tunnels = BTreeMap::new();
    let mut valves = BTreeMap::new();
    let mut names = vec![];
    let mut flows = vec![];
    for (k, v) in &get_data(puzzle_lines) {
        valves.insert(k.to_string(), v.0 as i64);
        flows.push(v.0);
        tunnels.insert(k.to_string(), v.1.clone());
        names.push(k.to_string());
    }

    let mut dist = vec![];
    for _ in 0..names.len() {
        dist.push(vec![99; names.len()]);
    }

    for (i, valve) in valves.keys().enumerate() {
        for neighbor in &tunnels[valve] {
            let index = names.iter().position(|r| r == neighbor).unwrap();
            let v = &mut dist[i];
            v[index] = 1;
        }
    }

    // Floyd-Marshall
    for k in 0..names.len() {
        for i in 0..names.len() {
            for j in 0..names.len() {
                dist[i][j] = dist[i][j].min(dist[i][k] + dist[k][j]);
            }
        }
    }

    let rest = flows
        .iter()
        .enumerate()
        .filter(|(_, f)| *f > &0)
        .map(|(i, _)| i as u64)
        .collect::<Vec<u64>>();
    //println!("names = {:?}", names);
    //let aa_index = names.iter().position(|r| r == "AA").unwrap();
    //println!("aa in names = {:?}", names.iter().position(|r| r == "AA").unwrap());
    //println!("rest = {:?}", rest);
    let mut cache = BTreeMap::<(usize, Vec<u64>, u64), u64>::new();
    //let mut m = dfs2(&dist, &flows, 0, &rest, 26, &mut cache);
    //m = m.max(dfs(&dist, &flows, 0, &rest, 26, &mut BTreeMap::<(usize, Vec<u64>, u64), u64>::new()));
    Ok(dfs2(&dist, &flows, 0, &rest, 26, &mut cache))
}

fn solve1(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    let mut tunnels = BTreeMap::new();
    let mut valves = BTreeMap::new();
    let mut names = vec![];
    let mut flows = vec![];
    for (k, v) in &get_data(puzzle_lines) {
        valves.insert(k.to_string(), v.0 as i64);
        flows.push(v.0);
        tunnels.insert(k.to_string(), v.1.clone());
        names.push(k.to_string());
    }

    let mut dist = vec![];
    for _ in 0..names.len() {
        dist.push(vec![99; names.len()]);
    }

    for (i, valve) in valves.keys().enumerate() {
        for neighbor in &tunnels[valve] {
            let index = names.iter().position(|r| r == neighbor).unwrap();
            let v = &mut dist[i];
            v[index] = 1;
        }
    }

    // Floyd-Marshall
    for k in 0..names.len() {
        for i in 0..names.len() {
            for j in 0..names.len() {
                dist[i][j] = dist[i][j].min(dist[i][k] + dist[k][j]);
            }
        }
    }

    let rest = flows
        .iter()
        .enumerate()
        .filter(|(_, f)| *f > &0)
        .map(|(i, _)| i as u64)
        .collect::<Vec<u64>>();
    //println!("names = {:?}", names);
    //let aa_index = names.iter().position(|r| r == "AA").unwrap();
    //println!("aa in names = {:?}", names.iter().position(|r| r == "AA").unwrap());
    //println!("rest = {:?}", rest);
    let mut cache = BTreeMap::<(usize, Vec<u64>, u64), u64>::new();
    Ok(dfs(&dist, &flows, 0, &rest, 30, &mut cache))
}

fn choose_one(v: &[u64]) -> impl Iterator<Item = (u64, Vec<u64>)> {
    v.iter()
        .enumerate()
        .map(|(i, val)| {
            (
                *val,
                [&v[..i], &v[(i + 1)..]]
                    .iter()
                    .copied()
                    .flatten()
                    .copied()
                    .collect::<Vec<_>>(),
            )
        })
        .collect::<Vec<(_, _)>>()
        .into_iter()
}

fn dfs(
    dist: &Vec<Vec<u64>>,
    flows: &[u64],
    cur: usize,
    rest: &[u64],
    t: u64,
    cache: &mut BTreeMap<(usize, Vec<u64>, u64), u64>,
) -> u64 {
    if let Some(val) = cache.get(&(cur, rest.to_vec(), t)) {
        return *val;
    }

    let mut maxval = 0;
    for (r, rr) in choose_one(rest) {
        let r = r as usize;
        if dist[cur][r] < t {
            maxval = maxval.max(
                flows[r] * (t - dist[cur][r] - 1)
                    + dfs(dist, flows, r, &rr, t - dist[cur][r] - 1, cache),
            );
        }
    }
    cache.insert((cur, rest.to_vec(), t), maxval);
    maxval
}

fn dfs2(
    dist: &Vec<Vec<u64>>,
    flows: &[u64],
    cur: usize,
    rest: &[u64],
    t: u64,
    cache: &mut BTreeMap<(usize, Vec<u64>, u64), u64>,
) -> u64 {
    if let Some(val) = cache.get(&(cur, rest.to_vec(), t)) {
        return *val;
    }

    let mut maxval = 0;
    for (r, rr) in choose_one(rest) {
        let r = r as usize;
        if dist[cur][r] < t {
            maxval = maxval.max(
                flows[r] * (t - dist[cur][r] - 1)
                    + dfs2(dist, flows, r, &rr, t - dist[cur][r] - 1, cache),
            );
            //maxval = maxval.max(dfs(dist, flows, 0, &rest, 26, &mut BTreeMap::<(usize, Vec<u64>, u64), u64>::new()));
        }
    }
    maxval = maxval.max(dfs(
        dist,
        flows,
        0,
        &rest,
        26,
        &mut BTreeMap::<(usize, Vec<u64>, u64), u64>::new(),
    ));
    cache.insert((cur, rest.to_vec(), t), maxval);
    maxval
}

fn part1(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    solve1(puzzle_lines)
}

fn part2(puzzle_lines: &[String]) -> Result<u64, Box<dyn Error>> {
    solve2(puzzle_lines)
}

fn main() -> Result<(), Box<dyn Error>> {
    // behave like a typical unix utility
    reset_sigpipe()?;
    let mut stdout = io::stdout().lock();

    // parse command line arguments
    let args = get_args();

    // read puzzle data into a list of String
    let puzzle_lines = read_data_lines(args.get_one::<std::path::PathBuf>("FILE"))?;

    // start a timer
    let timer = std::time::Instant::now();

    // ==============================================================

    writeln!(stdout, "Answer Part 1 = {}", part1(&puzzle_lines)?)?;
    writeln!(stdout, "Answer Part 2 = {}", part2(&puzzle_lines)?)?;

    if args.get_flag("time") {
        writeln!(stdout, "Total Runtime: {:?}", timer.elapsed())?;
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_data(filename: &str) -> Vec<String> {
        let file = std::path::PathBuf::from(filename);
        read_data_lines(Some(&file)).unwrap()
    }

    #[test]
    fn part1_example() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-example");
        assert_eq!(part1(&puzzle_lines)?, 1651);
        Ok(())
    }

    #[test]
    fn part1_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part1(&puzzle_lines)?, 1376);
        Ok(())
    }

    #[test]
    fn part2_example() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-example");
        assert_eq!(part2(&puzzle_lines)?, 1707);
        Ok(())
    }

    #[test]
    fn part2_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part2(&puzzle_lines)?, 1933);
        Ok(())
    }
}
