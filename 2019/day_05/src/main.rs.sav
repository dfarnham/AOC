use general::{get_args, read_trimmed_data_lines, reset_sigpipe, trim_split_on};
use std::error::Error;
use std::io::{self, Write};

fn get_data(puzzle_lines: &[String]) -> Result<Vec<i64>, Box<dyn Error>> {
    trim_split_on(&puzzle_lines[0], ',')
}

fn run_program(program: &[i64], input: i64) -> Result<i64, Box<dyn Error>> {
    let mut opcodes = program.to_owned();

    let mut result = 0;
    let mut i = 0;
    while i < opcodes.len() {
        let instruction = match opcodes[i] {
            99 => {
                break;
            }
            n => n,
        };

        //let mut params = vec![];
        let modes = instruction.to_string().chars().rev().skip(2).collect::<Vec<char>>();
        match instruction % 100 {
            1 | 2 => {
                let a = match !modes.is_empty() && modes[0] == '1' {
                    true => opcodes[i + 1],
                    false => opcodes[opcodes[i + 1] as usize],
                };

                let b = match modes.len() > 1 && modes[1] == '1' {
                    true => opcodes[i + 2],
                    false => opcodes[opcodes[i + 2] as usize],
                };

                let c = opcodes[i + 3] as usize;

                if instruction % 100 == 1 {
                    opcodes[c] = a + b;
                } else {
                    opcodes[c] = a * b;
                }
                i += 4;
            }
            3 => {
                let a = opcodes[i + 1] as usize;
                opcodes[a] = input;
                i += 2;
            }
            4 => {
                result = opcodes[opcodes[i + 1] as usize];
                println!("{result}");
                i += 2;
            }
            _ => return Err("invalid instruction".into()),
        }
    }
    //println!("opcodes = {opcodes:?}");
    Ok(result)
}

fn part1(puzzle_lines: &[String]) -> Result<i64, Box<dyn Error>> {
    let program = get_data(puzzle_lines)?;
    run_program(&program, 1)
}

fn part2(puzzle_lines: &[String]) -> Result<usize, Box<dyn Error>> {
    //Err("no solution".into())
    Ok(0)
}

fn main() -> Result<(), Box<dyn Error>> {
    // behave like a typical unix utility
    reset_sigpipe()?;
    let mut stdout = io::stdout().lock();

    // parse command line arguments
    let args = get_args();

    // read puzzle data into a list of String
    let puzzle_lines = read_trimmed_data_lines(args.get_one::<std::path::PathBuf>("FILE"))?;

    // start a timer
    let timer = std::time::Instant::now();

    // ==============================================================

    writeln!(stdout, "Answer Part 1 = {:?}", part1(&puzzle_lines)?)?;
    writeln!(stdout, "Answer Part 2 = {:?}", part2(&puzzle_lines)?)?;

    if args.get_flag("time") {
        writeln!(stdout, "Total Runtime: {:?}", timer.elapsed())?;
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_data(filename: &str) -> Vec<String> {
        let file = std::path::PathBuf::from(filename);
        read_trimmed_data_lines(Some(&file)).unwrap()
    }

    #[test]
    fn part1_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part1(&puzzle_lines)?, 7692125);
        Ok(())
    }

    /*
    #[test]
    fn part2_actual() -> Result<(), Box<dyn Error>> {
        let puzzle_lines = get_data("input-actual");
        assert_eq!(part2(&puzzle_lines)?, 3146);
        Ok(())
    }
    */
}
